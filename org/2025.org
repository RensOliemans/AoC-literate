:PROPERTIES:
:header-args:clojure: :results output :exports both :eval never-export
:END:
#+TITLE: AoC 2025
#+AUTHOR: Rens Oliemans
#+DESCRIPTION: My Advent of Code solutions for 2025
#+OPTIONS: toc:nil ^:t num:nil

#+begin_src clojure :results none :exports none
  (ns advent-of-code.2025
    (:require [advent-of-code.utils :as u]))
#+end_src

* [[https://adventofcode.com/2025/day/1][Day 1: Secret Entrance]]
:PROPERTIES:
:CUSTOM_ID: day1
:END:

** Part 1
We convert the input into numbers (=L68= would be =-68=, =R34= would be =34=). For part one we simply compute the entire list of numbers via =(reductions + 50 rotations)= and check how many are zero modulo 100.

#+begin_src clojure
  (def load-input (u/input-year "2025"))

  (defn convert-rotation "Converts a rotation string into a number.
    For example, L68 would be -68, and R48 would be 48."
    [rot]
    (let [direction (first rot)
          number (Integer/parseInt (subs rot 1))]
      (condp = direction
        \L (- number)
        \R number)))

  (u/part "1"
    (->> (load-input 1)
         u/to-lines
         (map convert-rotation)
         (reductions + 50)
         (map #(mod % 100))
         (filter zero?)
         count))
#+end_src

#+RESULTS:
: Part 1:  1018
: "Elapsed time: 5.555712 msecs"

** Part 2
We now also have to count how often the dial moves /across/ 0. We do this via the function =zero-counters=, which takes two numbers: before and after moving the dial (=from= and =to=). A couple of example movements with the corresponding amount of zeros seen:
- $105 \rightarrow 301 = 2$
- $-101 \rightarrow 100 = 3$
- $-155 \rightarrow -100 = 0$
- $-9900 \rightarrow -9925 = 0$

Thinking a bit about this, we can divide both =from= and =to= by =100= and take the difference. Whether we take the [[https://en.wikipedia.org/wiki/Floor_division][floor or ceiling]] division depends on whether =from= or =to= is higher. With =zero-counters= done it's straightforward:
#+begin_src clojure
  (defn zero-counters
    "When moving the dial from `from` to `to`, how often does the dial
    point at `0`, during or after the rotation?"
    [from to]
    (let [divver (if (< from to) Math/floorDiv Math/ceilDiv)]
      (let [a (divver from 100)
            b (divver to   100)]
        (Math/abs (- b a)))))

  (u/part "2"
    (->> (load-input 1)
         u/to-lines
         (map convert-rotation)
         (reductions + 50)
         (partition 2 1)
         (map (fn [[x y]] (zero-counters x y)))
         (reduce +)))
#+end_src

#+RESULTS:
: Part 2:  5815
: "Elapsed time: 132.196553 msecs"

* [[https://adventofcode.com/2025/day/2][Day 2: Gift Shop]]
:PROPERTIES:
:CUSTOM_ID: day2
:END:

** Part 1
Regex with backtrace, match a number twice for Part 1
#+begin_src clojure
  (defn- to-ranges
    "Converts todays puzzle input to a seq of float-pairs.
    For example, \"11-22,95-115\" will be converted to ((11 22) (95
    115))."
    [input]
    (->> input
         u/to-csvs
         u/parse-ranges))

  (defn solve
    [input regexp]
    (->> input
         to-ranges
         (pmap (fn [[start end]]
                 (filterv #(re-matches regexp (str %))
                          (range start (inc end)))))
         flatten
         (reduce +)))

  (u/part "1" (solve (load-input 2) #"^(\d+)\1$"))
#+end_src

#+RESULTS:
: Part 1:  13108371860
: "Elapsed time: 422.718813 msecs"

** Part 2
And simply match it more often for Part 2
#+begin_src clojure
  (u/part "2" (solve (load-input 2) #"^(\d+)\1+$"))
#+end_src

#+RESULTS:
: Part 2:  22471660255
: "Elapsed time: 448.995817 msecs"

* [[https://adventofcode.com/2025/day/3][Day 3: Lobby]]
** Part 1
#+begin_src clojure
  (defn- highest-value [line n]
    (let [c (count line)
          [sequence _]
          (reduce
           (fn [[current i] following]
             (loop [j 0]
               (if (>= j (count current))
                 (if (> n j)
                   [(conj current following) (inc i)]
                   [current (inc i)])
                 (if (and (> following (nth current j))
                          (<= (- n (inc j)) (- c (inc i))))
                   [(conj (vec (take j current)) following) (inc i)]
                   (recur (inc j))))))
           [[(first line)] 1]
           (rest line))]
      (->> sequence
           str/join
           Long/parseLong)))

  (defn- solve [input n]
    (->> input
         u/to-lines
         (map #(re-seq #"\d" %))
         (map #(map parse-long %))
         (map #(highest-value % n))
         (reduce +)))

  (u/part "1" (solve (load-input 3) 2))
#+end_src

#+RESULTS:
: Part 1:  17244
: "Elapsed time: 18.491415 msecs"

** Part 2
#+begin_src clojure
  (u/part "2" (solve (load-input 3) 12))
#+end_src

#+RESULTS:
: Part 2:  171435596092638
: "Elapsed time: 32.53128 msecs"
